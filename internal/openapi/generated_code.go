// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for CheckerPlayFrom.
const (
	CheckerPlayFromBar CheckerPlayFrom = "bar"
	CheckerPlayFromN1  CheckerPlayFrom = "1"
	CheckerPlayFromN10 CheckerPlayFrom = "10"
	CheckerPlayFromN11 CheckerPlayFrom = "11"
	CheckerPlayFromN12 CheckerPlayFrom = "12"
	CheckerPlayFromN13 CheckerPlayFrom = "13"
	CheckerPlayFromN14 CheckerPlayFrom = "14"
	CheckerPlayFromN15 CheckerPlayFrom = "15"
	CheckerPlayFromN16 CheckerPlayFrom = "16"
	CheckerPlayFromN17 CheckerPlayFrom = "17"
	CheckerPlayFromN18 CheckerPlayFrom = "18"
	CheckerPlayFromN19 CheckerPlayFrom = "19"
	CheckerPlayFromN2  CheckerPlayFrom = "2"
	CheckerPlayFromN20 CheckerPlayFrom = "20"
	CheckerPlayFromN21 CheckerPlayFrom = "21"
	CheckerPlayFromN22 CheckerPlayFrom = "22"
	CheckerPlayFromN23 CheckerPlayFrom = "23"
	CheckerPlayFromN24 CheckerPlayFrom = "24"
	CheckerPlayFromN3  CheckerPlayFrom = "3"
	CheckerPlayFromN4  CheckerPlayFrom = "4"
	CheckerPlayFromN5  CheckerPlayFrom = "5"
	CheckerPlayFromN6  CheckerPlayFrom = "6"
	CheckerPlayFromN7  CheckerPlayFrom = "7"
	CheckerPlayFromN8  CheckerPlayFrom = "8"
	CheckerPlayFromN9  CheckerPlayFrom = "9"
)

// Defines values for CheckerPlayTo.
const (
	CheckerPlayToN1  CheckerPlayTo = "1"
	CheckerPlayToN10 CheckerPlayTo = "10"
	CheckerPlayToN11 CheckerPlayTo = "11"
	CheckerPlayToN12 CheckerPlayTo = "12"
	CheckerPlayToN13 CheckerPlayTo = "13"
	CheckerPlayToN14 CheckerPlayTo = "14"
	CheckerPlayToN15 CheckerPlayTo = "15"
	CheckerPlayToN16 CheckerPlayTo = "16"
	CheckerPlayToN17 CheckerPlayTo = "17"
	CheckerPlayToN18 CheckerPlayTo = "18"
	CheckerPlayToN19 CheckerPlayTo = "19"
	CheckerPlayToN2  CheckerPlayTo = "2"
	CheckerPlayToN20 CheckerPlayTo = "20"
	CheckerPlayToN21 CheckerPlayTo = "21"
	CheckerPlayToN22 CheckerPlayTo = "22"
	CheckerPlayToN23 CheckerPlayTo = "23"
	CheckerPlayToN24 CheckerPlayTo = "24"
	CheckerPlayToN3  CheckerPlayTo = "3"
	CheckerPlayToN4  CheckerPlayTo = "4"
	CheckerPlayToN5  CheckerPlayTo = "5"
	CheckerPlayToN6  CheckerPlayTo = "6"
	CheckerPlayToN7  CheckerPlayTo = "7"
	CheckerPlayToN8  CheckerPlayTo = "8"
	CheckerPlayToN9  CheckerPlayTo = "9"
	CheckerPlayToOff CheckerPlayTo = "off"
)

// Defines values for MoveArgsPlayer.
const (
	O MoveArgsPlayer = "o"
	X MoveArgsPlayer = "x"
)

// Board defines model for Board.
type Board struct {
	// O Number of checkers in each point on the board.
	O CheckerLayout `json:"o"`

	// X Number of checkers in each point on the board.
	X CheckerLayout `json:"x"`
}

// CheckerLayout Number of checkers in each point on the board.
type CheckerLayout struct {
	N1  *int `json:"1,omitempty"`
	N10 *int `json:"10,omitempty"`
	N11 *int `json:"11,omitempty"`
	N12 *int `json:"12,omitempty"`
	N13 *int `json:"13,omitempty"`
	N14 *int `json:"14,omitempty"`
	N15 *int `json:"15,omitempty"`
	N16 *int `json:"16,omitempty"`
	N17 *int `json:"17,omitempty"`
	N18 *int `json:"18,omitempty"`
	N19 *int `json:"19,omitempty"`
	N2  *int `json:"2,omitempty"`
	N20 *int `json:"20,omitempty"`
	N21 *int `json:"21,omitempty"`
	N22 *int `json:"22,omitempty"`
	N23 *int `json:"23,omitempty"`
	N24 *int `json:"24,omitempty"`
	N3  *int `json:"3,omitempty"`
	N4  *int `json:"4,omitempty"`
	N5  *int `json:"5,omitempty"`
	N6  *int `json:"6,omitempty"`
	N7  *int `json:"7,omitempty"`
	N8  *int `json:"8,omitempty"`
	N9  *int `json:"9,omitempty"`
	Bar *int `json:"bar,omitempty"`
}

// CheckerPlay Move coordinates
type CheckerPlay struct {
	// From Point where the checker is currently
	From CheckerPlayFrom `json:"from"`

	// To Point where the checker will move
	To CheckerPlayTo `json:"to"`
}

// CheckerPlayFrom Point where the checker is currently
type CheckerPlayFrom string

// CheckerPlayTo Point where the checker will move
type CheckerPlayTo string

// EvalInfo Evaluation details
type EvalInfo struct {
	// Cubeful Was cube decision considered?
	Cubeful bool `json:"cubeful"`

	// Plies How many turns ahead was considered. Typically 3, but may terminate earlier if probabilty already looks certain.
	Plies int `json:"plies"`
}

// Evaluation Score of the move
type Evaluation struct {
	// Diff Equity difference compared to the best move
	Diff float32 `json:"diff"`

	// Eq Equity value of the move relative to zero (neutral)
	Eq float32 `json:"eq"`

	// Info Evaluation details
	Info *EvalInfo `json:"info,omitempty"`

	// Probability Probabilty of win/lose after making this move. Values are percentage proportions of 1, i.e. 1 means 100% certainty, 0.5 means 50% etc.
	Probability *Probability `json:"probability,omitempty"`
}

// Move Backgammon move
type Move struct {
	// Evaluation Score of the move
	Evaluation *Evaluation    `json:"evaluation,omitempty"`
	Play       *[]CheckerPlay `json:"play,omitempty"`
}

// MoveArgs defines model for MoveArgs.
type MoveArgs struct {
	Board Board `json:"board"`

	// Cubeful Is doubling cube in use?
	Cubeful *bool `json:"cubeful,omitempty"`

	// Dice 2-slot array of dice values been thrown
	Dice []int `json:"dice"`

	// MaxMoves Max number of moves to return. if not supplied means return all available moves.
	MaxMoves *int `json:"max-moves,omitempty"`

	// Player Player on roll
	Player MoveArgsPlayer `json:"player"`

	// ScoreMoves Whether or not to calculate equities for each available move. Takes longer.
	ScoreMoves *bool `json:"score-moves,omitempty"`
}

// MoveArgsPlayer Player on roll
type MoveArgsPlayer string

// Probability Probabilty of win/lose after making this move. Values are percentage proportions of 1, i.e. 1 means 100% certainty, 0.5 means 50% etc.
type Probability struct {
	// Lose Probabilty of losing the game. Always `1 - win`
	Lose float32 `json:"lose"`

	// LoseBG Probabilty of losing a backgammon
	LoseBG float32 `json:"loseBG"`

	// LoseG Probabilty of losing a gammon
	LoseG float32 `json:"loseG"`

	// Win Probabilty of winning the game
	Win float32 `json:"win"`

	// WinBG Probability of winning a backgammon
	WinBG float32 `json:"winBG"`

	// WinG Probability of winning a gammon
	WinG float32 `json:"winG"`
}

// PostGetmovesJSONRequestBody defines body for PostGetmoves for application/json ContentType.
type PostGetmovesJSONRequestBody = MoveArgs

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get moves
	// (POST /getmoves)
	PostGetmoves(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostGetmoves converts echo context to params.
func (w *ServerInterfaceWrapper) PostGetmoves(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGetmoves(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/getmoves", wrapper.PostGetmoves)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
